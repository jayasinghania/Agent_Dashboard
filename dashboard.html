<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Indoo â€” Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;500;600;700;800;900&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
  <link rel="stylesheet" href="dashboard.css" />
  <style>
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TABLE VISIBILITY FIXES
       Root causes identified from dashboard.css:
       1. .table-card has overflow:hidden + slideUp animation with
          fill-mode:both â€” if animation doesn't complete the whole
          card stays at opacity:0
       2. .t-scroll has max-height:340px which may clip rows
       3. tbody tr had slide-up class causing rows to start invisible
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Force the table card to always be fully visible */
    .table-card {
      opacity: 1 !important;
      transform: none !important;
      animation: none !important;
      overflow: visible !important;   /* was overflow:hidden â€” was clipping content */
    }

    /* Let the scroll container grow naturally, cap it generously */
    .t-scroll {
      overflow-x: auto !important;
      overflow-y: auto !important;
      max-height: 600px !important;   /* was 340px â€” increase so rows show */
      height: auto !important;
    }

    /* Guarantee every row and cell is visible */
    #tBody tr { opacity: 1 !important; transform: none !important; animation: none !important; visibility: visible !important; }
    #tBody td { opacity: 1 !important; visibility: visible !important; }

    /* Keep rounded corners without clipping via outline trick */
    .table-card { border-radius: 18px; outline: 1.5px solid var(--border); border: none !important; }

    /* Tighten columns so the 7-column table fits without horizontal scroll on most screens */
    .t-scroll th, .t-scroll td { white-space: nowrap; padding: 9px 12px !important; font-size: .76rem; }
    .t-scroll th:nth-child(1), .t-scroll td:nth-child(1) { min-width: 140px; }
    .t-scroll th:nth-child(2), .t-scroll td:nth-child(2) { min-width: 148px; }
    .t-scroll th:nth-child(3), .t-scroll td:nth-child(3) { min-width:  68px; }
    .t-scroll th:nth-child(4), .t-scroll td:nth-child(4) { min-width:  60px; }
    .t-scroll th:nth-child(5), .t-scroll td:nth-child(5) { min-width: 115px; }
    .t-scroll th:nth-child(6), .t-scroll td:nth-child(6) { min-width:  85px; }
    .t-scroll th:nth-child(7), .t-scroll td:nth-child(7) { min-width:  78px; }

    /* Token cell */
    .tok-cell { font-size:.76rem; font-weight:700; color:var(--ink2); cursor:default; }
    .tok-sep  { color:var(--ink4); margin:0 3px; font-weight:400; }
    /* Token chip in transcript */
    .tok-chip { background:linear-gradient(135deg,#e8f4fd,#d4eaf7); color:#2d7fc1; border:1.5px solid #b8d9f0; font-weight:700; cursor:default; }
    /* Stat card sub labels */
    #sv3sub { font-size:.66rem; line-height:1.5; }
    #sv5sub { font-size:.66rem; line-height:1.5; }
    /* Index pill colours */
    .sp-cost   { background:#fff7ed; color:#c2540a; border:1.5px solid #fed7aa; }
    .sp-tokens { background:#f0fdf4; color:#166534; border:1.5px solid #bbf7d0; }
  </style>
</head>
<body>

<!-- TOPBAR -->
<div class="topbar">
  <a class="back-btn" href="index.html">â†</a>
  <div class="agent-av" id="agentAv" data-color="lav">ğŸ¤–</div>
  <div class="agent-info">
    <div class="agent-name" id="agentName">Loadingâ€¦</div>
    <div class="agent-id"   id="agentIdEl">â€”</div>
  </div>
  <div style="flex:1"></div>
  <div class="tab-bar">
    <button class="tab-btn active" id="tabOv" onclick="switchTab('ov')">ğŸ“Š Overview</button>
    <button class="tab-btn"        id="tabCh" onclick="switchTab('ch')">ğŸ’¬ Chat History</button>
  </div>
</div>
<div class="loading-bar" id="loadBar"></div>

<!-- â•â• OVERVIEW â•â• -->
<div id="overviewScreen" class="screen active">

  <!-- Stats -->
  <div class="stats-row" id="statsRow">
    <div class="stat-card" style="animation-delay:0ms">
      <div class="sc-label">Number of Calls</div>
      <div class="sc-val" id="sv1">â€”</div>
      <div class="sc-sub">total sessions</div>
    </div>
    <div class="stat-card" style="animation-delay:50ms">
      <div class="sc-label">Average Duration</div>
      <div class="sc-val" id="sv2">â€”</div>
      <div class="sc-sub">per session</div>
    </div>
    <div class="stat-card" style="animation-delay:100ms">
      <div class="sc-label">Total Tokens Used</div>
      <div class="sc-val" id="sv3">â€”</div>
      <div class="sc-sub" id="sv3sub">input + output</div>
    </div>
    <div class="stat-card" style="animation-delay:150ms">
      <div class="sc-label">Avg Tokens / Session</div>
      <div class="sc-val" id="sv4">â€”</div>
      <div class="sc-sub">per conversation</div>
    </div>
    <div class="stat-card" style="animation-delay:200ms">
      <div class="sc-label">Total LLM Cost</div>
      <div class="sc-val" id="sv5">â€”</div>
      <div class="sc-sub" id="sv5sub">USD (calculated)</div>
    </div>
    <div class="stat-card" style="animation-delay:250ms">
      <div class="sc-label">Avg LLM Cost</div>
      <div class="sc-val" id="sv6">â€”</div>
      <div class="sc-sub">per session</div>
    </div>
  </div>

  <!-- Chart -->
  <div class="chart-card">
    <div class="card-head">
      <div>
        <div class="card-title">Calls over time</div>
        <div class="card-sub">Number of conversations per day</div>
      </div>
      <div class="legend">
        <div class="leg-item"><div class="leg-dot" style="background:var(--lav)"></div>Sessions</div>
        <div class="leg-item" id="llmLegend" style="display:none"><div class="leg-dot" style="background:var(--peach)"></div>LLM Cost ($)</div>
      </div>
    </div>
    <div class="chart-wrap"><canvas id="mainChart"></canvas></div>
  </div>



</div>

<!-- â•â• CHAT â•â• -->
<div id="chatScreen" class="screen">

  <!-- LEFT: Users sidebar -->
  <aside class="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">ğŸ‘¥ Users</div>
    </div>
    <div class="search-box">
      <div class="search-wrap">
        <span class="search-ico">ğŸ”</span>
        <input class="search-input" id="userSearch" type="text" placeholder="Search usersâ€¦" oninput="filterUsers()"/>
      </div>
    </div>
    <div class="users-wrap" id="usersList">
      <div class="ph"><div class="phi">ğŸ‘¥</div>Loadingâ€¦</div>
    </div>
  </aside>

  <!-- MIDDLE: Sessions timeline + transcript -->
  <div class="chat-middle">
    <!-- session list -->
    <div class="timeline">
      <div class="tl-top">
        <div class="tl-lbl">ğŸ“… Sessions</div>
        <div class="tl-cnt" id="tlCnt">â€”</div>
      </div>
      <div class="dfbar" id="dfbar"><span class="df-lbl">Filter:</span></div>
      <div class="tl-scroll" id="tlScroll">
        <div class="center-state">
          <div class="cs-icon">ğŸ—“ï¸</div>
          <div class="cs-title">No sessions yet</div>
          <div class="cs-sub">Select a user from the sidebar.</div>
        </div>
      </div>
    </div>

    <!-- transcript -->
    <div class="tr-panel" id="trPanel">
      <div class="hint"><div class="hint-icon">ğŸ’¬</div><p>Select a session to read the full transcript âœ¨</p></div>
    </div>
  </div>

  <!-- RIGHT: Conversation info panel -->
  <aside class="info-panel" id="infoPanel">
    <div class="ip-header">
      <div class="ip-title">â„¹ï¸ Conversation Info</div>
    </div>
    <div class="ip-body" id="ipBody">
      <div class="ip-empty">
        <div class="ip-empty-icon">ğŸ“‹</div>
        <div class="ip-empty-text">Select a session to see details</div>
      </div>
    </div>
  </aside>

</div>

<script>
// â”€â”€ URL PARAMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const P          = new URLSearchParams(location.search);
const agentName  = P.get('name')    || 'Agent';
const agentIdVal = P.get('agentId') || '';
const apiKey     = P.get('apiKey')  || '';
const agentEmoji = P.get('emoji')   || 'ğŸ¤–';
const agentColor = P.get('color')   || 'lav';

document.title = `Indoo â€” ${agentName}`;
document.getElementById('agentName').textContent = agentName;
document.getElementById('agentIdEl').textContent = agentIdVal || 'No agent ID';
const avEl = document.getElementById('agentAv');
avEl.textContent = agentEmoji; avEl.dataset.color = agentColor;

if (!apiKey) {
  document.getElementById('usersList').innerHTML = `<div class="ph"><div class="phi">ğŸ”‘</div>No API key.<br/><a href="index.html">â† Go back</a></div>`;
}

// â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let allConvs = [], detailCache = {}, userMap = {};
let activeUser = null, activeConv = null, activeDayFilter = null;
let chartInst  = null;

// â”€â”€ TABS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function switchTab(t) {
  document.getElementById('tabOv').classList.toggle('active', t==='ov');
  document.getElementById('tabCh').classList.toggle('active', t==='ch');
  document.getElementById('overviewScreen').classList.toggle('active', t==='ov');
  document.getElementById('chatScreen').classList.toggle('active', t==='ch');
}

// â”€â”€ UTILS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const esc = s => s ? String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') : '';
const fmtDur  = s  => { if (!s) return 'â€”'; if (s<60) return s+'s'; return `${Math.floor(s/60)}m ${s%60}s`; };
const fmtTime = u  => u ? new Date(u*1000).toLocaleTimeString('en-IN',{hour:'2-digit',minute:'2-digit'}) : 'â€”';
const fmtDate = u  => u ? new Date(u*1000).toLocaleDateString('en-IN',{day:'numeric',month:'short',year:'numeric'}) : 'â€”';
const daySort = u  => u ? new Date(u*1000).toISOString().slice(0,10) : '0000-00-00';
const initials= n  => { if (!n||n==='Unknown User') return '?'; const p=n.trim().split(' '); return p.length>=2?(p[0][0]+p[p.length-1][0]).toUpperCase():n.slice(0,2).toUpperCase(); };
const stClass = s  => ({done:'st-done',failed:'st-failed',processing:'st-processing'}[s]||'st-in-progress');
const getUnix = c  => { const d=detailCache[c.conversation_id]; return d?.metadata?.start_time_unix_secs||c.metadata?.start_time_unix_secs||null; };

function dayLabel(u) {
  if (!u) return 'Unknown Date';
  const d=new Date(u*1000),t=new Date(),y=new Date(); y.setDate(t.getDate()-1);
  if (d.toDateString()===t.toDateString()) return 'ğŸŒŸ Today';
  if (d.toDateString()===y.toDateString()) return 'ğŸŒ™ Yesterday';
  return d.toLocaleDateString('en-IN',{weekday:'short',day:'numeric',month:'long'});
}
function dayLabelShort(u) {
  if (!u) return '?';
  const d=new Date(u*1000),t=new Date(),y=new Date(); y.setDate(t.getDate()-1);
  if (d.toDateString()===t.toDateString()) return 'Today';
  if (d.toDateString()===y.toDateString()) return 'Yesterday';
  return d.toLocaleDateString('en-IN',{day:'numeric',month:'short'});
}

// â”€â”€ TOKEN EXTRACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Recursively scan any object for token-like numeric fields
function deepScanTokens(obj, depth=0) {
  if (!obj || typeof obj !== 'object' || depth > 4) return {};
  const found = {};
  for (const [k, v] of Object.entries(obj)) {
    const kl = k.toLowerCase();
    if (typeof v === 'number' && (
      kl.includes('token') || kl.includes('usage') || kl.includes('cost') ||
      kl.includes('credit') || kl.includes('character') || kl.includes('llm')
    )) {
      found[k] = v;
    } else if (v && typeof v === 'object' && !Array.isArray(v)) {
      Object.assign(found, deepScanTokens(v, depth + 1));
    }
  }
  return found;
}

// Returns { input, output, total, model, source } or null
function getTokens(det) {
  if (!det) return null;
  const m  = det.metadata || {};
  const lu = m.llm_usage  || m.usage || m.token_usage || m.llm || {};

  // â”€â”€ Try every known ElevenLabs field shape â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const input =
    lu.input_tokens          ?? lu.prompt_tokens          ?? lu.input               ??
    m.input_tokens           ?? m.prompt_tokens           ?? m.llm_input_tokens      ??
    m.prompt_token_count     ?? m.llm_usage?.input_tokens ?? null;

  const output =
    lu.output_tokens         ?? lu.completion_tokens      ?? lu.output              ??
    m.output_tokens          ?? m.completion_tokens       ?? m.llm_output_tokens     ??
    m.completion_token_count ?? m.llm_usage?.output_tokens ?? null;

  const combined =
    lu.total_tokens          ?? lu.total                  ??
    m.total_tokens           ?? m.llm_total_tokens        ?? m.token_count           ??
    m.tokens                 ?? m.llm_usage?.total_tokens ?? null;

  const model =
    m.llm_model ?? m.model ?? m.llm_model_used ?? m.llm_name ??
    det.agent_info?.llm ?? det.agent?.llm ?? lu.model ?? null;

  if (input !== null || output !== null || combined !== null) {
    const i = input    !== null ? Number(input)    : (combined !== null ? Math.round(Number(combined)*0.6) : 0);
    const o = output   !== null ? Number(output)   : (combined !== null ? Math.round(Number(combined)*0.4) : 0);
    return { input: i, output: o, total: i + o, model: model || 'unknown', source: 'tokens' };
  }

  // â”€â”€ Deep scan fallback: walk the whole object looking for numeric token fields â”€â”€
  const allFields = deepScanTokens(det);
  console.log('[Indoo] Deep scan found numeric fields:', allFields);
  const allKeys = Object.keys(allFields);

  // Try to match input/output from scan results
  const iKey = allKeys.find(k => /input|prompt/.test(k.toLowerCase()));
  const oKey = allKeys.find(k => /output|completion/.test(k.toLowerCase()));
  const tKey = allKeys.find(k => /total.*tok|tok.*total/.test(k.toLowerCase()));

  if (iKey || oKey || tKey) {
    const i = iKey ? Number(allFields[iKey]) : 0;
    const o = oKey ? Number(allFields[oKey]) : 0;
    const t = tKey ? Number(allFields[tKey]) : i + o;
    return { input: i||Math.round(t*0.6), output: o||Math.round(t*0.4), total: t||i+o, model: model||'unknown', source: 'deep-scan' };
  }

  return null;  // truly no token data
}

// â”€â”€ DURATION-BASED COST ESTIMATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// When no token data exists, estimate from call duration.
// ElevenLabs Conversational AI pricing: ~$0.10/min LLM usage on standard plans.
// We mark these as estimates so the UI can show them differently.
function getDurationCost(det, convListItem) {
  const dur = det?.metadata?.call_duration_secs || convListItem?.metadata?.call_duration_secs || 0;
  if (!dur) return null;
  const mins = dur / 60;
  const cost = mins * 0.10;   // $0.10 per minute
  return { cost, dur, isEstimate: true };
}

// â”€â”€ COST CALCULATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Prices per 1M tokens (input / output) in USD
// Covers all models ElevenLabs Conversational AI supports as of 2025
const MODEL_PRICES = {
  // OpenAI
  'gpt-4o':                      { in: 2.50,  out: 10.00 },
  'gpt-4o-mini':                 { in: 0.15,  out: 0.60  },
  'gpt-4o-2024-11-20':           { in: 2.50,  out: 10.00 },
  'gpt-4-turbo':                 { in: 10.00, out: 30.00 },
  'gpt-4':                       { in: 30.00, out: 60.00 },
  'gpt-3.5-turbo':               { in: 0.50,  out: 1.50  },
  'o1':                          { in: 15.00, out: 60.00 },
  'o1-mini':                     { in: 3.00,  out: 12.00 },
  // Anthropic Claude
  'claude-3-5-sonnet':           { in: 3.00,  out: 15.00 },
  'claude-3-5-sonnet-20241022':  { in: 3.00,  out: 15.00 },
  'claude-3-5-haiku':            { in: 0.80,  out: 4.00  },
  'claude-3-opus':               { in: 15.00, out: 75.00 },
  'claude-3-haiku':              { in: 0.25,  out: 1.25  },
  // Google Gemini
  'gemini-1.5-flash':            { in: 0.075, out: 0.30  },
  'gemini-1.5-pro':              { in: 1.25,  out: 5.00  },
  'gemini-2.0-flash':            { in: 0.10,  out: 0.40  },
  // Meta Llama (via Groq / hosted)
  'llama-3.1-70b':               { in: 0.59,  out: 0.79  },
  'llama-3.1-8b':                { in: 0.05,  out: 0.08  },
  // Mistral
  'mistral-large':               { in: 3.00,  out: 9.00  },
  'mistral-small':               { in: 0.20,  out: 0.60  },
  // Default fallback (GPT-4o pricing)
  'default':                     { in: 2.50,  out: 10.00 },
};

function lookupPrice(modelStr) {
  if (!modelStr) return MODEL_PRICES['default'];
  const m = modelStr.toLowerCase();
  // Exact match first
  if (MODEL_PRICES[m]) return MODEL_PRICES[m];
  // Partial match â€” find the first key that appears in the model string
  for (const key of Object.keys(MODEL_PRICES)) {
    if (key !== 'default' && m.includes(key)) return MODEL_PRICES[key];
  }
  return MODEL_PRICES['default'];
}

function calcTokenCost(tokens) {
  if (!tokens) return null;
  const price = lookupPrice(tokens.model);
  return (tokens.input / 1_000_000) * price.in + (tokens.output / 1_000_000) * price.out;
}

// Returns { cost, isEstimate, tok? } or null
// Tries token-based cost first, falls back to duration-based estimate ($0.10/min)
function getSessionCost(det, convListItem) {
  const tok = getTokens(det);
  if (tok) {
    const cost = calcTokenCost(tok);
    if (cost !== null) return { cost, isEstimate: false, tok };
  }
  return getDurationCost(det, convListItem);
}

// Convenience: return raw number (used in chart buckets)
function getLLMCost(det, convListItem) {
  const s = getSessionCost(det, convListItem);
  return s ? s.cost : null;
}

function fmtLLM(c, isEstimate=false) {
  if (c === null || c === undefined) return null;
  const p = isEstimate ? '~' : '';
  if (c === 0) return `${p}$0.00`;
  if (c < 0.000001) return `${p}<$0.000001`;
  if (c < 0.001) return `${p}$${c.toFixed(6)}`;
  return `${p}$${c.toFixed(4)}`;
}

function fmtTokens(n) {
  if (!n && n !== 0) return 'â€”';
  if (n >= 1_000_000) return (n/1_000_000).toFixed(2)+'M';
  if (n >= 1_000)     return (n/1_000).toFixed(1)+'K';
  return String(n);
}

// â”€â”€ NAME EXTRACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function extractUserName(det) {
  if (!det) return null;
  const d = det.conversation_initiation_client_data;
  if (d?.dynamic_variables?.user_name) return d.dynamic_variables.user_name;
  if (d?.dynamic_variables) {
    for (const k of Object.keys(d.dynamic_variables)) {
      if (k.toLowerCase().includes('name')||k.toLowerCase().includes('user')) {
        const v=d.dynamic_variables[k];
        if (v&&typeof v==='string'&&v.length<40) return v;
      }
    }
  }
  const vars=d?.conversation_config_override?.agent?.prompt?.variables;
  if (Array.isArray(vars)){const m=vars.find(v=>v.name?.toLowerCase().includes('name'));if(m?.value)return m.value;}
  if (det.metadata?.user_name) return det.metadata.user_name;
  const tr=det.transcript||[], fa=tr.find(t=>t.role==='agent');
  if (fa?.message){
    const msg=fa.message;
    const g=msg.match(/(?:hey|hello|hi|howdy|welcome|good\s+(?:morning|afternoon|evening))[,!]?\s+([A-Z][a-z]{1,30})/i);
    if (g) return g[1];
    const mid=msg.match(/\b(?:hey|hi|hello)\s+([A-Z][a-z]{1,30})\b/i);
    if (mid) return mid[1];
  }
  for (const t of tr.slice(0,20)){
    if (t.role==='agent'&&t.message){const m=t.message.match(/\b(?:hey|hello|hi)\s+([A-Z][a-z]{1,30})\b/i);if(m)return m[1];}
  }
  return null;
}

// â”€â”€ FETCH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fetchAll() {
  if (!apiKey) return;
  document.getElementById('loadBar').classList.add('on');
  try {
    // â”€â”€ Step 1: fetch ALL pages of the conversation list â”€â”€
    let allFetched = [], cursor = null, page = 0;
    setProgress('Fetching conversationsâ€¦', 0, 0);
    do {
      let url = 'https://api.elevenlabs.io/v1/convai/conversations?page_size=100';
      if (agentIdVal) url += `&agent_id=${encodeURIComponent(agentIdVal)}`;
      if (cursor) url += `&cursor=${encodeURIComponent(cursor)}`;
      const res = await fetch(url, {headers:{'xi-api-key': apiKey}});
      if (!res.ok) { const e=await res.json().catch(()=>({})); throw new Error(e?.detail?.message||`API ${res.status}`); }
      const data = await res.json();
      const page_convs = data.conversations || [];
      allFetched.push(...page_convs);
      cursor = data.next_cursor || data.cursor || null; // handle both field names
      page++;
      setProgress(`Fetched ${allFetched.length} conversationsâ€¦`, 0, 0);
      // safety: stop after 20 pages (2000 convs)
      if (page >= 20) break;
    } while (cursor);

    allConvs = allFetched;

    if (!allConvs.length) {
      document.getElementById('usersList').innerHTML=`<div class="ph"><div class="phi">ğŸŒµ</div>No conversations yet.</div>`;
      renderOverview(); return;
    }

    // â”€â”€ Step 2: batch-fetch details (10 at a time) to avoid rate limits â”€â”€
    const BATCH = 10;
    let done = 0;
    setProgress(`Loading session detailsâ€¦ 0 / ${allConvs.length}`, done, allConvs.length);

    for (let i = 0; i < allConvs.length; i += BATCH) {
      const batch = allConvs.slice(i, i + BATCH);
      await Promise.allSettled(batch.map(c => fetchDetail(c.conversation_id)));
      done += batch.length;
      setProgress(`Loading session detailsâ€¦ ${Math.min(done, allConvs.length)} / ${allConvs.length}`, done, allConvs.length);
      // small delay between batches to respect rate limits
      if (i + BATCH < allConvs.length) await sleep(120);
    }

    // â”€â”€ Step 3: log the first detail so we can see real field names â”€â”€
    const firstDetail = Object.values(detailCache)[0];
    if (firstDetail) {
      console.log('[Indoo] Sample metadata fields:', Object.keys(firstDetail.metadata || {}));
      console.log('[Indoo] Sample metadata values:', firstDetail.metadata);
      console.log('[Indoo] Full detail sample:', firstDetail);
    }

    buildUserMap();
    renderUsers(Object.keys(userMap).sort());
    renderOverview();

  } catch(e) {
    document.getElementById('usersList').innerHTML=`<div class="ph"><div class="phi">ğŸ˜¬</div>${esc(e.message)}</div>`;
    console.error('[Indoo] fetchAll error:', e);
  } finally {
    document.getElementById('loadBar').classList.remove('on');
    clearProgress();
  }
}

function setProgress(msg, done, total) {
  const el = document.getElementById('usersList');
  const pct = total > 0 ? Math.round((done/total)*100) : 0;
  el.innerHTML = `
    <div class="ph" style="gap:10px;display:flex;flex-direction:column;align-items:center;">
      <div class="spinner"></div>
      <div style="font-size:.75rem;font-weight:700;color:var(--ink2);text-align:center;">${msg}</div>
      ${total > 0 ? `
        <div style="width:100%;background:var(--border);border-radius:50px;height:6px;overflow:hidden;">
          <div style="width:${pct}%;height:100%;background:linear-gradient(90deg,var(--lav),var(--peach));border-radius:50px;transition:width .3s;"></div>
        </div>
        <div style="font-size:.65rem;color:var(--ink3);font-weight:600;">${pct}% complete</div>
      ` : ''}
    </div>`;
}

function clearProgress() { /* will be replaced by renderUsers */ }

const sleep = ms => new Promise(r => setTimeout(r, ms));

async function fetchDetail(id) {
  if (detailCache[id]) return detailCache[id];
  try {
    const res=await fetch(`https://api.elevenlabs.io/v1/convai/conversations/${id}`,{headers:{'xi-api-key':apiKey}});
    if (!res.ok) return null;
    const d=await res.json(); detailCache[id]=d; return d;
  } catch{return null;}
}

// â”€â”€ BUILD USER MAP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildUserMap() {
  userMap={};
  for (const c of allConvs){
    const det=detailCache[c.conversation_id];
    const name=extractUserName(det)||'Unknown User';
    if (!userMap[name]) userMap[name]=[];
    userMap[name].push(c);
  }
}

// â”€â”€ OVERVIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderOverview() {
  const dets = allConvs.map(c=>detailCache[c.conversation_id]);
  const n    = allConvs.length;

  // durations
  const durs = allConvs.map(c => {
    const det = detailCache[c.conversation_id];
    return det?.metadata?.call_duration_secs || c.metadata?.call_duration_secs || 0;
  }).filter(Boolean);
  const avgD = durs.length ? Math.round(durs.reduce((a,b)=>a+b,0)/durs.length) : 0;

  // tokens
  const tokensList = dets.filter(Boolean).map(d => getTokens(d)).filter(Boolean);
  const totInput  = tokensList.reduce((a,t) => a + t.input,  0);
  const totOutput = tokensList.reduce((a,t) => a + t.output, 0);
  const totTokens = totInput + totOutput;
  const avgTokens = tokensList.length ? Math.round(totTokens / tokensList.length) : 0;
  const hasTokens = tokensList.length > 0;

  // models detected
  const modelSet = [...new Set(tokensList.map(t=>t.model).filter(m=>m&&m!=='unknown'))];

  // LLM cost â€” token-based where available, duration-estimate otherwise
  const sessionCosts = allConvs.map((c, i) => getSessionCost(dets[i], c)).filter(Boolean);
  const totLLM  = sessionCosts.reduce((a, s) => a + s.cost, 0);
  const avgLLM  = sessionCosts.length ? totLLM / sessionCosts.length : null;
  const hasLLM  = sessionCosts.length > 0;
  const anyEstimate = sessionCosts.some(s => s.isEstimate);
  const allEstimate = sessionCosts.length > 0 && sessionCosts.every(s => s.isEstimate);

  // debug
  const sampleDet = dets.find(Boolean);
  if (sampleDet) {
    console.log('[Indoo] All metadata keys:', Object.keys(sampleDet.metadata||{}));
    console.log('[Indoo] token probe result:', getTokens(sampleDet));
    console.log('[Indoo] cost probe result:', calcTokenCost(getTokens(sampleDet)));
    console.log('[Indoo] Full metadata sample:', sampleDet.metadata);
  }

  document.getElementById('sv1').textContent = n || '0';
  document.getElementById('sv2').textContent = fmtDur(avgD);

  if (hasTokens) {
    document.getElementById('sv3').textContent = fmtTokens(totTokens);
    document.getElementById('sv3sub').textContent = `${fmtTokens(totInput)} in Â· ${fmtTokens(totOutput)} out`;
    document.getElementById('sv4').textContent = fmtTokens(avgTokens);
  } else {
    document.getElementById('sv3').textContent = 'â€”';
    document.getElementById('sv3sub').textContent = 'no token data from API';
    document.getElementById('sv4').textContent = 'â€”';
  }

  document.getElementById('sv5').textContent = hasLLM ? fmtLLM(totLLM, anyEstimate) : 'â€”';
  if (hasLLM) {
    if (allEstimate) {
      document.getElementById('sv5sub').textContent = '~est. from duration ($0.10/min)';
    } else if (anyEstimate) {
      document.getElementById('sv5sub').textContent = 'mix of tokens + duration est.';
    } else if (modelSet.length) {
      document.getElementById('sv5sub').textContent = `Model: ${modelSet.slice(0,2).join(', ')}`;
    }
  }
  document.getElementById('sv6').textContent = avgLLM !== null ? fmtLLM(avgLLM, anyEstimate) : 'â€”';

  document.getElementById('llmLegend').style.display = hasLLM ? 'flex' : 'none';

  renderChart(hasLLM);
}

function renderChart(hasLLM) {
  // bucket by day
  const buckets={};
  for (const c of allConvs){
    const u=getUnix(c);
    const sk=u?new Date(u*1000).toISOString().slice(0,10):'0000';
    const lbl=u?new Date(u*1000).toLocaleDateString('en-IN',{day:'numeric',month:'short'}):'?';
    if (!buckets[sk]) buckets[sk]={lbl,n:0,llm:0};
    buckets[sk].n++;
    const det=detailCache[c.conversation_id];
    const llm=getLLMCost(det);
    if (llm!==null) buckets[sk].llm+=llm;
  }
  const keys  =Object.keys(buckets).sort();
  const labels=keys.map(k=>buckets[k].lbl);
  const counts=keys.map(k=>buckets[k].n);
  const llmVs =keys.map(k=>parseFloat(buckets[k].llm.toFixed(5)));

  if (chartInst){chartInst.destroy();chartInst=null;}
  const ctx=document.getElementById('mainChart').getContext('2d');
  chartInst=new Chart(ctx,{
    type:'line',
    data:{
      labels,
      datasets:[
        {
          label:'Sessions',data:counts,
          borderColor:'#9b7ff4',backgroundColor:'rgba(155,127,244,0.08)',
          borderWidth:2.5,pointBackgroundColor:'#9b7ff4',
          pointRadius:4,pointHoverRadius:6,tension:0.35,fill:true,yAxisID:'y',
        },
        ...(hasLLM?[{
          label:'LLM Cost ($)',data:llmVs,
          borderColor:'#ff8c6b',backgroundColor:'rgba(255,140,107,0.07)',
          borderWidth:2,pointBackgroundColor:'#ff8c6b',
          pointRadius:4,pointHoverRadius:6,tension:0.35,fill:true,
          borderDash:[5,4],yAxisID:'y2',
        }]:[]),
      ],
    },
    options:{
      responsive:true,maintainAspectRatio:false,
      interaction:{mode:'index',intersect:false},
      plugins:{
        legend:{display:false},
        tooltip:{
          backgroundColor:'#fff',borderColor:'#ede9e4',borderWidth:1.5,
          titleColor:'#2d2926',bodyColor:'#6b6560',padding:12,cornerRadius:10,
          titleFont:{family:'Nunito',weight:'800',size:12},
          bodyFont:{family:'Nunito',weight:'600',size:11},
          callbacks:{
            label:ctx=>ctx.dataset.label==='LLM Cost ($)'
              ?`  LLM Cost: $${ctx.parsed.y.toFixed(5)}`
              :`  Sessions: ${ctx.parsed.y}`
          }
        },
      },
      scales:{
        x:{grid:{color:'rgba(0,0,0,0.04)'},ticks:{font:{family:'Nunito',weight:'700',size:10},color:'#aba49c'}},
        y:{position:'left',grid:{color:'rgba(0,0,0,0.05)'},ticks:{font:{family:'Nunito',weight:'700',size:10},color:'#9b7ff4',stepSize:1},beginAtZero:true},
        ...(hasLLM?{y2:{position:'right',grid:{drawOnChartArea:false},ticks:{font:{family:'Nunito',weight:'700',size:10},color:'#ff8c6b',callback:v=>'$'+v.toFixed(4)},beginAtZero:true}}:{}),
      },
    },
  });
}

function renderTable() {
  const body=document.getElementById('tBody');
  const sorted=[...allConvs].sort((a,b)=>(getUnix(b)||0)-(getUnix(a)||0));
  if (!sorted.length){body.innerHTML=`<tr><td colspan="7" style="text-align:center;color:var(--ink3);padding:28px;">No sessions found</td></tr>`;return;}
  body.innerHTML='';
  sorted.forEach((c,i)=>{
    const det  = detailCache[c.conversation_id];
    const u    = getUnix(c);
    const dur  = c.metadata?.call_duration_secs;
    const uT   = det?(det.transcript||[]).filter(t=>t.role==='user').length:0;
    const name = (det?extractUserName(det):null)||'Unknown User';
    const tok  = det ? getTokens(det) : null;
    const sess = getSessionCost(det, c);
    const ls   = sess ? fmtLLM(sess.cost, sess.isEstimate) : null;
    const tr   = document.createElement('tr');

    // Token cell: "1.2K / 0.4K" with tooltip showing model
    let tokCell = 'â€”';
    if (tok) {
      const tip = tok.model && tok.model !== 'unknown'
        ? `title="Model: ${esc(tok.model)} Â· $${lookupPrice(tok.model).in}/$${lookupPrice(tok.model).out} per 1M in/out"`
        : '';
      tokCell = `<span class="tok-cell" ${tip}>${fmtTokens(tok.input)} <span class="tok-sep">/</span> ${fmtTokens(tok.output)}</span>`;
    }

    tr.innerHTML=`
      <td><div class="td-user"><div class="td-av">${esc(initials(name))}</div><span class="td-name">${esc(name)}</span></div></td>
      <td class="mono">${u?`${fmtDate(u)} Â· ${fmtTime(u)}`:'â€”'}</td>
      <td class="mono">${fmtDur(dur)}</td>
      <td>${uT||'â€”'}</td>
      <td class="mono">${tokCell}</td>
      <td><span class="td-badge ${stClass(c.status)}">${c.status}</span></td>
      <td class="td-llm ${ls?'':'empty'}">${ls||'â€”'}</td>`;
    body.appendChild(tr);
  });
}

// â”€â”€ RENDER USERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderUsers(names) {
  const el=document.getElementById('usersList');
  if (!names.length){el.innerHTML=`<div class="ph"><div class="phi">ğŸ”</div>No users match!</div>`;return;}
  el.innerHTML=`<div class="users-header">ğŸ‘¥ Users (${names.length})</div>`;
  names.forEach((name,i)=>{
    const convs=userMap[name]||[], dur=convs.reduce((a,c)=>a+(c.metadata?.call_duration_secs||0),0);
    const div=document.createElement('div');
    div.className='user-row slide-up'+(name===activeUser?' active':'');
    div.style.animationDelay=(i*22)+'ms';
    div.innerHTML=`
      <div class="u-av">${esc(initials(name))}</div>
      <div class="u-info">
        <div class="u-name">${esc(name)}</div>
        <div class="u-meta">${convs.length} session${convs.length!==1?'s':''} Â· ${fmtDur(dur)}</div>
      </div>
      <div class="u-badge">${convs.length}</div>`;
    div.onclick=()=>selectUser(name);
    el.appendChild(div);
  });
}
function filterUsers(){
  const q=document.getElementById('userSearch').value.trim().toLowerCase();
  renderUsers(Object.keys(userMap).filter(n=>n.toLowerCase().includes(q)).sort());
}

// â”€â”€ SELECT USER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function selectUser(name){
  activeUser=name;activeConv=null;activeDayFilter=null;
  document.querySelectorAll('.user-row').forEach(r=>r.classList.toggle('active',r.querySelector('.u-name')?.textContent===name));
  const convs=userMap[name]||[];
  let tQ=0,tD=0,dN=0;
  convs.forEach(c=>{
    const d=detailCache[c.conversation_id];
    if (d) tQ+=(d.transcript||[]).filter(t=>t.role==='user').length;
    if (c.metadata?.call_duration_secs){tD+=c.metadata.call_duration_secs;dN++;}
  });
  const strip=document.getElementById('userStrip');
  if(strip){strip.style.display='flex';
  document.getElementById('usAv').textContent   =initials(name);
  document.getElementById('usName').textContent =name;
  document.getElementById('usSub').textContent  =convs.length+' sessions';
  document.getElementById('upS').textContent    =convs.length;
  document.getElementById('upQ').textContent    =tQ||'â€”';
  document.getElementById('upA').textContent    =dN?fmtDur(Math.round(tD/dN)):'â€”';}
  buildDateFilter(convs);
  renderTimeline(convs);
  showHint();
  switchTab('ch');
}

// â”€â”€ DATE FILTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildDateFilter(convs){
  const bar=document.getElementById('dfbar'), dm={};
  for (const c of convs){const u=getUnix(c);if(!u)continue;const k=daySort(u);if(!dm[k])dm[k]=dayLabelShort(u);}
  const days=Object.keys(dm).sort().reverse();
  if (days.length<=1){bar.className='dfbar';return;}
  bar.innerHTML='<span class="df-lbl">Filter:</span>';
  const ac=document.createElement('div');
  ac.className='df-chip all active';ac.textContent=`All (${convs.length})`;
  ac.onclick=()=>applyDayFilter(null,convs);bar.appendChild(ac);
  days.forEach(k=>{
    const cnt=convs.filter(c=>daySort(getUnix(c))===k).length;
    const chip=document.createElement('div');
    chip.className='df-chip';chip.dataset.day=k;
    chip.textContent=`${dm[k]} (${cnt})`;
    chip.onclick=()=>applyDayFilter(k,convs);bar.appendChild(chip);
  });
  bar.className='dfbar vis';
}
function applyDayFilter(dk,all){
  activeDayFilter=dk;activeConv=null;
  document.querySelectorAll('.df-chip').forEach(c=>c.classList.toggle('active',dk===null?c.classList.contains('all'):c.dataset.day===dk));
  renderTimeline(dk?all.filter(c=>daySort(getUnix(c))===dk):all);
  showHint();
}

// â”€â”€ TIMELINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTimeline(convs){
  const scr=document.getElementById('tlScroll');
  document.getElementById('tlCnt').textContent=`${convs.length} session${convs.length!==1?'s':''}`;
  if (!convs.length){scr.innerHTML=`<div class="center-state"><div class="cs-icon">ğŸ“­</div><div class="cs-title">No sessions</div></div>`;return;}
  const groups={};
  for (const c of convs){
    const k=daySort(getUnix(c)),l=dayLabel(getUnix(c));
    if (!groups[k]) groups[k]={l,convs:[]};
    groups[k].convs.push(c);
  }
  const days=Object.keys(groups).sort().reverse();
  scr.innerHTML='';
  days.forEach((day,di)=>{
    const {l,convs:dc}=groups[day];
    dc.sort((a,b)=>(getUnix(b)||0)-(getUnix(a)||0));
    const grp=document.createElement('div');
    grp.className='day-grp slide-up';grp.style.animationDelay=(di*40)+'ms';
    grp.innerHTML=`<div class="day-strip"><div class="day-pill">${esc(l)}</div><div class="day-line"></div><div class="day-n">${dc.length}</div></div>`;
    dc.forEach((c,ci)=>{
      const det=detailCache[c.conversation_id];
      const dur=c.metadata?.call_duration_secs,time=getUnix(c);
      const uT=det?(det.transcript||[]).filter(t=>t.role==='user').length:0;
      const prev=(det?.transcript||[]).find(t=>t.role==='user')?.message||'No preview';
      const tok=det?getTokens(det):null;
      const sess=getSessionCost(det,c);
      const ls=sess?fmtLLM(sess.cost,sess.isEstimate):null;
      const card=document.createElement('div');
      card.className='sess-card slide-up'+(c.conversation_id===activeConv?' active':'');
      card.style.animationDelay=(di*40+ci*18)+'ms';
      card.innerHTML=`
        <div class="sc-top">
          <div class="sc-time">${fmtTime(time)}</div>
          <div class="sc-stat ${stClass(c.status)}">${c.status}</div>
        </div>
        <div class="sc-prev">${esc(prev)}</div>
        <div class="sc-chips">
          ${dur?`<span class="sc-chip">â± ${fmtDur(dur)}</span>`:''}
          ${uT?`<span class="sc-chip">ğŸ’¬ ${uT} quer${uT!==1?'ies':'y'}</span>`:''}
          ${tok?`<span class="sc-chip">ğŸ”¢ ${fmtTokens(tok.total)}</span>`:''}
          ${ls?`<span class="sc-chip llm">ğŸ’° ${ls}</span>`:''}
        </div>`;
      card.onclick=()=>loadTranscript(c.conversation_id,activeUser,card);
      grp.appendChild(card);
    });
    scr.appendChild(grp);
  });
}

// â”€â”€ TRANSCRIPT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadTranscript(id,userName,cardEl){
  document.querySelectorAll('.sess-card').forEach(c=>c.classList.remove('active'));
  cardEl.classList.add('active');activeConv=id;
  const panel=document.getElementById('trPanel');
  panel.innerHTML=`<div class="center-state"><div class="spinner"></div></div>`;
  try{
    const data=await fetchDetail(id);
    if (!data) throw new Error('Empty response');
    renderTranscript(data,userName);
  }catch(e){
    panel.innerHTML=`<div class="center-state"><div class="cs-icon">ğŸ˜¬</div><div class="cs-title">Couldn't load</div><div class="cs-sub">${esc(e.message)}</div></div>`;
  }
}

function renderTranscript(data,userName){
  const {conversation_id,status,metadata,transcript=[],agent_name}=data;
  const start=metadata?.start_time_unix_secs,dur=metadata?.call_duration_secs;
  const uT=transcript.filter(t=>t.role==='user').length;
  const dName=userName||extractUserName(data)||'User';
  const ini=initials(dName);
  const tok=getTokens(data);
  const sess=getSessionCost(data, null);
  const ls=sess?fmtLLM(sess.cost,sess.isEstimate):null;

  // â”€â”€ Populate right info panel â”€â”€
  const charging=metadata?.charging||{};
  const ipBody=document.getElementById('ipBody');
  const ipRows=[
    {label:'Conversation ID',value:conversation_id,mono:true,small:true},
    {label:'Status',value:`<span class="sc-stat ${stClass(status)}" style="font-size:.65rem">${status}</span>`,html:true},
    {label:'Date',value:start?fmtDate(start):'â€”'},
    {label:'Time',value:start?fmtTime(start):'â€”'},
    {label:'Duration',value:fmtDur(dur)},
    {label:'Cost',value:charging.cost!=null?`$${Number(charging.cost).toFixed(4)}`:(ls||'â€”')},
    {label:'LLM Price',value:charging.llm_price!=null?`$${Number(charging.llm_price).toFixed(6)}`:( tok?`$${lookupPrice(tok.model).in}/$${lookupPrice(tok.model).out}/1M`:'â€”')},
    {label:'LLM Cost',value:charging.llm_cost!=null?`$${Number(charging.llm_cost).toFixed(6)}`:(ls||'â€”')},
  ];
  ipBody.innerHTML=`
    <div class="ip-user">
      <div class="ip-av">${esc(ini)}</div>
      <div class="ip-uname">${esc(dName)}</div>
    </div>
    <div class="ip-divider"></div>
    ${ipRows.map(r=>`
      <div class="ip-row">
        <div class="ip-lbl">${r.label}</div>
        <div class="ip-val${r.mono?' mono':''}${r.small?' ip-val-sm':''}">${r.html?r.value:esc(String(r.value))}</div>
      </div>`).join('')}`;

  const panel=document.getElementById('trPanel');
  panel.className='tr-panel pop-in';
  panel.innerHTML=`
    <div class="tr-head">
      <div class="tr-row1">
        <div class="tr-av">${esc(ini)}</div>
        <div class="tr-info">
          <div class="tr-name">Chat with <em>${esc(dName)}</em></div>
          <div class="tr-id">${esc(conversation_id)}</div>
        </div>
      </div>
    </div>
    <div class="msgs" id="msgsBox"></div>`;

  const box=document.getElementById('msgsBox');
  if (!transcript.length){
    box.innerHTML=`<div class="center-state"><div class="cs-icon">ğŸ“­</div><div class="cs-title">No messages</div></div>`;
    return;
  }
  transcript.forEach((t,i)=>{
    const isUser=t.role==='user',ts=t.time_in_call_secs;
    const tStr=ts!=null?`${String(Math.floor(ts/60)).padStart(2,'0')}:${String(ts%60).padStart(2,'0')}`:null;
    const row=document.createElement('div');
    row.className=`msg-wrap ${isUser?'user':'agent'} slide-up`;
    row.style.animationDelay=Math.min(i*12,300)+'ms';
    row.innerHTML=`
      <div class="msg-av ${isUser?'ut':'at'}">${isUser?esc(ini):'ğŸ¤–'}</div>
      <div class="msg-col">
        <div class="msg-who">${isUser?esc(dName):(esc(agent_name)||'Agent')}${tStr?` Â· ${tStr}`:''}</div>
        <div class="msg-bub">${esc(t.message||t.text||'')}</div>
      </div>`;
    box.appendChild(row);
  });
  box.scrollTop=0;
}

function showHint(){
  document.getElementById('trPanel').innerHTML=`<div class="hint"><div class="hint-icon">ğŸ’¬</div><p>Select a session to read the full transcript âœ¨</p></div>`;
  document.getElementById('ipBody').innerHTML=`<div class="ip-empty"><div class="ip-empty-icon">ğŸ“‹</div><div class="ip-empty-text">Select a session to see details</div></div>`;
}

document.addEventListener('keydown',e=>{
  if ((e.metaKey||e.ctrlKey)&&e.key==='k'){e.preventDefault();document.getElementById('userSearch').focus();}
});

fetchAll();
</script>
</body>
</html>